<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カスタム棒人間バトル：ビルド＆ファイト【Web格ゲー】</title>
    <meta name="description" content="合計10ポイントのステータス割り振りで最強の棒人間を作れ。Webブラウザで遊べるカスタム格闘ゲーム。">
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto+Mono:wght@400;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212;
            --ui-bg: rgba(20, 20, 30, 0.95);
            --accent: #ff4757;
            --text: #ffffff;
            --neon-blue: #2ed573;
            --neon-yellow: #ffa502;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-color);
            font-family: 'Roboto Mono', monospace;
            color: var(--text);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* UI Container */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* Screens */
        .screen {
            pointer-events: auto;
            background: var(--ui-bg);
            padding: 40px;
            border-radius: 12px;
            border: 2px solid #333;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            max-width: 600px;
            width: 90%;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-family: 'Black Ops One', cursive;
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            color: var(--accent);
            text-transform: uppercase;
            text-shadow: 2px 2px 0px #fff;
            line-height: 1.2;
        }

        .hidden {
            display: none !important;
        }

        /* Customization Controls */
        .stat-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-size: 1.2rem;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            font-size: 1.1rem;
        }

        .stat-value {
            color: var(--neon-blue);
            font-weight: bold;
            width: 40px;
            text-align: right;
        }

        input[type="range"] {
            width: 55%;
            cursor: pointer;
            accent-color: var(--accent);
        }

        .weapon-select {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 25px 0;
        }

        .weapon-btn {
            background: #333;
            border: 2px solid #555;
            color: #fff;
            padding: 10px 15px;
            cursor: pointer;
            font-family: inherit;
            transition: 0.2s;
            font-size: 0.9rem;
        }

        .weapon-btn.selected {
            border-color: var(--neon-yellow);
            background: #444;
            box-shadow: 0 0 15px rgba(255, 165, 2, 0.4);
            transform: scale(1.05);
        }

        .action-btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Black Ops One', cursive;
            cursor: pointer;
            margin-top: 20px;
            transform: skew(-10deg);
            transition: 0.2s;
            box-shadow: 0 4px 0 #b33939;
        }

        .action-btn:hover {
            transform: skew(-10deg) translateY(-2px);
            box-shadow: 0 6px 0 #b33939;
        }

        .action-btn:active {
            transform: skew(-10deg) translateY(2px);
            box-shadow: 0 2px 0 #b33939;
        }

        /* HUD (In Game) */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }

        .health-bar-container {
            width: 40%;
            height: 30px;
            background: #333;
            border: 2px solid #fff;
            position: relative;
            transform: skew(-20deg);
        }

        .health-bar {
            height: 100%;
            background: var(--neon-blue);
            width: 100%;
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .enemy-bar {
            background: var(--accent);
            float: right;
        }

        #timer {
            font-family: 'Black Ops One', cursive;
            font-size: 3rem;
            color: white;
            text-shadow: 0 0 10px black;
        }

        .controls-hint {
            margin-top: 20px;
            font-size: 0.75rem;
            color: #888;
            text-align: left;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 6px;
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">

        <div id="hud" class="hidden">
            <div class="health-bar-container">
                <div id="playerHealth" class="health-bar"></div>
            </div>
            <div id="timer">60</div>
            <div class="health-bar-container" style="border-color: #ff4757;">
                <div id="enemyHealth" class="health-bar enemy-bar"></div>
            </div>
        </div>

        <div id="startScreen" class="screen">
            <h1>Stick Forge</h1>
            <p style="letter-spacing: 2px; margin-bottom: 20px;">BUILD YOUR FIGHTER</p>

            <div class="stat-header">
                <span>TOTAL POINTS</span>
                <span id="pointsDisplay" style="color:var(--neon-yellow);">7 / 10</span>
            </div>

            <div class="stat-row">
                <label>STR (攻撃)</label>
                <input type="range" id="strRange" min="1" max="8" value="1" oninput="updatePoints('strRange')">
                <span id="strVal" class="stat-value">1</span>
            </div>
            <div class="stat-row">
                <label>AGI (速度)</label>
                <input type="range" id="agiRange" min="1" max="8" value="1" oninput="updatePoints('agiRange')">
                <span id="agiVal" class="stat-value">1</span>
            </div>
            <div class="stat-row">
                <label>VIT (体力)</label>
                <input type="range" id="vitRange" min="1" max="8" value="1" oninput="updatePoints('vitRange')">
                <span id="vitVal" class="stat-value">1</span>
            </div>

            <p style="margin-top: 25px; font-size: 0.9rem; color: #aaa;">SELECT WEAPON</p>
            <div class="weapon-select">
                <button class="weapon-btn selected" onclick="selectWeapon('sword', this)">SWORD<br><span
                        style="font-size:0.7em">バランス</span></button>
                <button class="weapon-btn" onclick="selectWeapon('axe', this)">AXE<br><span
                        style="font-size:0.7em">高威力・遅</span></button>
                <button class="weapon-btn" onclick="selectWeapon('spear', this)">SPEAR<br><span
                        style="font-size:0.7em">リーチ・速</span></button>
            </div>

            <button class="action-btn" onclick="startGame()">BATTLE START</button>

            <div class="controls-hint">
                <strong>操作方法:</strong><br>
                [A][D] 移動 | [W] ジャンプ | [SPACE] 攻撃<br>
                ※ポイントは合計10まで割り振れます。
            </div>
        </div>

        <div id="gameOverScreen" class="screen hidden">
            <h1 id="winnerText">YOU WIN</h1>
            <button class="action-btn" onclick="location.reload()">RE-FORGE (再戦)</button>
        </div>
    </div>

    <script>
        // --- 1. Game Constants & Setup ---
        const canvas = document.getElementById('gameCanvas');
        const c = canvas.getContext('2d');

        // Dynamic Resize
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        const GRAVITY = 0.7;
        let GROUND_Y = canvas.height - 100;

        // Stats Limit
        const MAX_TOTAL_POINTS = 10;

        // Input State
        const keys = {
            a: { pressed: false },
            d: { pressed: false },
            w: { pressed: false },
            space: { pressed: false }
        };

        let animationId;
        let timer = 60;
        let timerId;
        let gameRunning = false;

        // --- 2. Logic Functions (Stats & Build) ---

        function updatePoints(changedId) {
            const strInput = document.getElementById('strRange');
            const agiInput = document.getElementById('agiRange');
            const vitInput = document.getElementById('vitRange');

            let str = parseInt(strInput.value);
            let agi = parseInt(agiInput.value);
            let vit = parseInt(vitInput.value);

            let currentTotal = str + agi + vit;

            // ポイント上限チェック
            if (currentTotal > MAX_TOTAL_POINTS) {
                const excess = currentTotal - MAX_TOTAL_POINTS;

                // 操作したスライダーの値を戻す
                if (changedId === 'strRange') {
                    str -= excess;
                    strInput.value = str;
                } else if (changedId === 'agiRange') {
                    agi -= excess;
                    agiInput.value = agi;
                } else if (changedId === 'vitRange') {
                    vit -= excess;
                    vitInput.value = vit;
                }
                currentTotal = MAX_TOTAL_POINTS;
            }

            // UI更新
            document.getElementById('strVal').innerText = str;
            document.getElementById('agiVal').innerText = agi;
            document.getElementById('vitVal').innerText = vit;

            const remaining = MAX_TOTAL_POINTS - currentTotal;
            document.getElementById('pointsDisplay').innerText = `${currentTotal} / ${MAX_TOTAL_POINTS}`;

            if (remaining === 0) {
                document.getElementById('pointsDisplay').style.color = 'var(--neon-blue)';
            } else {
                document.getElementById('pointsDisplay').style.color = 'var(--neon-yellow)';
            }
        }

        // 初期化実行
        updatePoints();

        let selectedWeapon = 'sword';
        function selectWeapon(type, btn) {
            selectedWeapon = type;
            document.querySelectorAll('.weapon-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
        }

        // --- 3. Classes ---

        class Sprite {
            constructor({ position, velocity, color = 'red', offset = { x: 0, y: 0 } }) {
                this.position = position;
                this.velocity = velocity;
                this.width = 50;
                this.height = 150;
                this.lastKey;
                this.attackBox = {
                    position: { x: this.position.x, y: this.position.y },
                    offset: offset,
                    width: 100,
                    height: 50
                };
                this.color = color;
                this.isAttacking;
                this.health = 100;
                this.maxHealth = 100;

                // Stats
                this.damage = 10;
                this.speed = 5;
                this.jumpPower = -15;
                this.weaponType = 'sword';

                this.dead = false;
            }

            draw() {
                c.strokeStyle = this.color;
                c.lineWidth = 4;
                c.fillStyle = this.color;

                // Simple Stickman Draw
                const x = this.position.x;
                const y = this.position.y;
                const w = this.width;
                const h = this.height;

                // Head
                c.beginPath();
                c.arc(x + w / 2, y, 20, 0, Math.PI * 2);
                c.stroke();
                // Body
                c.beginPath();
                c.moveTo(x + w / 2, y + 20);
                c.lineTo(x + w / 2, y + 80);
                c.stroke();
                // Legs
                c.beginPath();
                c.moveTo(x + w / 2, y + 80);
                c.lineTo(x, y + h);
                c.moveTo(x + w / 2, y + 80);
                c.lineTo(x + w, y + h);
                c.stroke();

                // Arms & Weapon Logic
                const facingRight = this.attackBox.offset.x >= 0;
                const armOriginX = x + w / 2;
                const armOriginY = y + 40;

                c.beginPath();
                c.moveTo(armOriginX, armOriginY);

                let handX, handY;
                if (this.isAttacking) {
                    handX = armOriginX + (facingRight ? 60 : -60);
                    handY = armOriginY + 10;
                } else {
                    handX = armOriginX + (facingRight ? 30 : -30);
                    handY = armOriginY + 40;
                }
                c.lineTo(handX, handY);
                c.stroke();

                this.drawWeapon(handX, handY, facingRight);
            }

            drawWeapon(handX, handY, facingRight) {
                c.fillStyle = '#cbd5e1'; // Metal color
                const dir = facingRight ? 1 : -1;

                if (this.weaponType === 'sword') {
                    // Blade
                    c.fillRect(handX, handY - 30, 40 * dir, 6);
                    // Hilt
                    c.fillStyle = '#475569';
                    c.fillRect(handX, handY - 5, 10 * dir, 10);
                } else if (this.weaponType === 'axe') {
                    // Handle
                    c.fillStyle = '#8B4513';
                    c.fillRect(handX, handY - 40, 6 * dir, 60);
                    // Head
                    c.fillStyle = '#94a3b8';
                    const headX = handX + (5 * dir);
                    c.fillRect(headX, handY - 40, 25 * dir, 20);
                } else if (this.weaponType === 'spear') {
                    // Shaft
                    c.fillStyle = '#8B4513';
                    c.fillRect(handX - (20 * dir), handY, 100 * dir, 4);
                    // Tip
                    c.fillStyle = '#cbd5e1';
                    c.fillRect(handX + (80 * dir), handY - 1, 15 * dir, 6);
                }
            }

            update() {
                this.draw();
                if (!this.dead) {
                    this.position.x += this.velocity.x;
                    this.position.y += this.velocity.y;
                }

                // Gravity & Floor Collision
                if (this.position.y + this.height + this.velocity.y >= GROUND_Y) {
                    this.velocity.y = 0;
                    this.position.y = GROUND_Y - this.height;
                } else {
                    this.velocity.y += GRAVITY;
                }

                // Attack Box Sync
                if (this.lastKey === 'a') {
                    this.attackBox.offset.x = -this.attackBox.width;
                } else {
                    this.attackBox.offset.x = 0;
                }

                this.attackBox.position.x = this.position.x + this.attackBox.offset.x; // Fixed offset logic
                // Ensure attack box is centered on player when attacking
                if (this.attackBox.offset.x < 0) {
                    this.attackBox.position.x = this.position.x - (this.attackBox.width - this.width);
                } else {
                    this.attackBox.position.x = this.position.x;
                }

                this.attackBox.position.y = this.position.y;

                // Boundary
                if (this.position.x < 0) this.position.x = 0;
                if (this.position.x + this.width > canvas.width) this.position.x = canvas.width - this.width;
            }

            attack() {
                if (this.isAttacking) return;
                this.isAttacking = true;
                setTimeout(() => {
                    this.isAttacking = false;
                }, 100 * (6 / this.speed)); // Speed affects recovery
            }

            takeHit(amt) {
                this.health -= amt;
                if (this.health <= 0) {
                    this.health = 0;
                    this.dead = true;
                }
            }
        }

        class Particle {
            constructor({ position, velocity, color }) {
                this.position = position;
                this.velocity = velocity;
                this.radius = Math.random() * 5 + 3;
                this.color = color;
                this.alpha = 1;
            }
            draw() {
                c.save();
                c.globalAlpha = this.alpha;
                c.fillStyle = this.color;
                c.fillRect(this.position.x, this.position.y, this.radius, this.radius);
                c.restore();
            }
            update() {
                this.draw();
                this.velocity.x *= 0.95;
                this.velocity.y += 0.3;
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
                this.alpha -= 0.05;
            }
        }

        // --- 4. Global Variables ---
        let player, enemy;
        let particles = [];

        function createParticles(x, y, color, amount = 10) {
            for (let i = 0; i < amount; i++) {
                particles.push(new Particle({
                    position: { x: x, y: y },
                    velocity: {
                        x: (Math.random() - 0.5) * 15,
                        y: (Math.random() - 0.5) * 15
                    },
                    color: color
                }));
            }
        }

        function screenShake() {
            const intensity = 8;
            canvas.style.transform = `translate(${Math.random() * intensity - intensity / 2}px, ${Math.random() * intensity - intensity / 2}px)`;
            setTimeout(() => {
                canvas.style.transform = 'translate(0,0)';
            }, 50);
        }

        function rectangularCollision({ rectangle1, rectangle2 }) {
            return (
                rectangle1.attackBox.position.x + rectangle1.attackBox.width >= rectangle2.position.x &&
                rectangle1.attackBox.position.x <= rectangle2.position.x + rectangle2.width &&
                rectangle1.attackBox.position.y + rectangle1.attackBox.height >= rectangle2.position.y &&
                rectangle1.attackBox.position.y <= rectangle2.position.y + rectangle2.height
            )
        }

        function determineWinner({ player, enemy, timerId }) {
            clearTimeout(timerId);
            document.getElementById('winnerText').style.display = 'flex';
            document.getElementById('gameOverScreen').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');

            if (player.health === enemy.health) {
                document.getElementById('winnerText').innerText = 'DRAW';
                document.getElementById('winnerText').style.color = 'white';
            } else if (player.health > enemy.health) {
                document.getElementById('winnerText').innerText = 'YOU WIN!';
                document.getElementById('winnerText').style.color = 'var(--neon-blue)';
            } else {
                document.getElementById('winnerText').innerText = 'YOU LOSE...';
                document.getElementById('winnerText').style.color = 'var(--accent)';
            }
            gameRunning = false;
        }

        function decreaseTimer() {
            if (timer > 0) {
                timerId = setTimeout(decreaseTimer, 1000);
                timer--;
                document.getElementById('timer').innerText = timer;
            } else {
                determineWinner({ player, enemy, timerId });
            }
        }

        function startGame() {
            GROUND_Y = canvas.height - 100;

            const pStr = parseInt(document.getElementById('strRange').value);
            const pAgi = parseInt(document.getElementById('agiRange').value);
            const pVit = parseInt(document.getElementById('vitRange').value);

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');

            // Player Setup (Balanced Multipliers for Low Points)
            // STR: 1pt = 5dmg ... 8pt = 40dmg (Avg 3pt = 15)
            // AGI: 1pt = 2spd ... 8pt = 16spd (Avg 3pt = 6)
            // VIT: 1pt = 25hp ... 8pt = 200hp (Avg 3.3pt = ~85)

            player = new Sprite({
                position: { x: 100, y: 0 },
                velocity: { x: 0, y: 0 },
                offset: { x: 0, y: 0 },
                color: '#2ed573'
            });
            player.maxHealth = pVit * 25;
            player.health = player.maxHealth;
            player.speed = 2 + (pAgi * 1.5); // Base speed + scaling
            player.damage = pStr * 5;
            player.weaponType = selectedWeapon;

            // Weapon Modifiers
            if (selectedWeapon === 'axe') {
                player.damage *= 1.4;
                player.speed *= 0.85;
                player.attackBox.width = 80;
            }
            if (selectedWeapon === 'spear') {
                player.damage *= 0.8;
                player.speed *= 1.1;
                player.attackBox.width = 180;
            }

            // Enemy Setup (Random Build)
            enemy = new Sprite({
                position: { x: canvas.width - 200, y: 0 },
                velocity: { x: 0, y: 0 },
                offset: { x: -50, y: 0 },
                color: '#ff4757'
            });
            enemy.weaponType = ['sword', 'axe', 'spear'][Math.floor(Math.random() * 3)];

            // Random Stats for Enemy (Total ~10)
            const eStr = Math.floor(Math.random() * 5) + 2;
            const eVit = Math.floor(Math.random() * 5) + 2;
            const eAgi = 10 - eStr - eVit; // Remainder

            enemy.maxHealth = Math.max(2, eVit) * 25;
            enemy.health = enemy.maxHealth;
            enemy.damage = Math.max(2, eStr) * 5;
            enemy.speed = 2 + (Math.max(1, eAgi) * 1.5);

            // Weapon Modifiers Enemy
            if (enemy.weaponType === 'axe') {
                enemy.damage *= 1.4;
                enemy.speed *= 0.85;
                enemy.attackBox.width = 80;
            }
            if (enemy.weaponType === 'spear') {
                enemy.damage *= 0.8;
                enemy.speed *= 1.1;
                enemy.attackBox.width = 180;
            }

            particles = [];
            gameRunning = true;
            timer = 60;
            decreaseTimer();
            animate();
        }

        // --- 5. Game Loop ---
        function animate() {
            if (!gameRunning) return;
            animationId = window.requestAnimationFrame(animate);

            // Draw BG
            c.fillStyle = '#0f172a';
            c.fillRect(0, 0, canvas.width, canvas.height);
            // Floor
            c.fillStyle = '#1e293b';
            c.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);

            player.update();
            enemy.update();

            // Player Move
            player.velocity.x = 0;
            if (keys.a.pressed && player.lastKey === 'a') {
                player.velocity.x = -player.speed;
            } else if (keys.d.pressed && player.lastKey === 'd') {
                player.velocity.x = player.speed;
            }

            // AI Logic
            const dist = player.position.x - enemy.position.x;
            enemy.velocity.x = 0;

            if (!enemy.dead && !player.dead) {
                // Face player logic is handled in update() via lastKey simulation or offset
                // Here we just set velocity
                const attackRange = enemy.attackBox.width - 20;

                if (Math.abs(dist) > attackRange) {
                    if (dist > 0) {
                        enemy.velocity.x = enemy.speed * 0.6;
                        enemy.lastKey = 'd';
                    } else {
                        enemy.velocity.x = -enemy.speed * 0.6;
                        enemy.lastKey = 'a';
                    }
                } else {
                    // In range
                    if (Math.random() < 0.03) enemy.attack();
                }

                // Random jump
                if (Math.random() < 0.005 && enemy.position.y + enemy.height >= GROUND_Y) {
                    enemy.velocity.y = -12;
                }
            }

            // Hit Detection
            // Player Attack
            if (rectangularCollision({ rectangle1: player, rectangle2: enemy }) &&
                player.isAttacking && player.currentAttackFrame !== frameCount) {

                player.isAttacking = false;
                enemy.takeHit(player.damage);
                createParticles(enemy.position.x + enemy.width / 2, enemy.position.y + enemy.height / 2, '#ff4757');
                screenShake();
                document.getElementById('enemyHealth').style.width = (enemy.health / enemy.maxHealth) * 100 + '%';
                if (enemy.health <= 0) determineWinner({ player, enemy, timerId });
            }

            // Enemy Attack
            if (rectangularCollision({ rectangle1: enemy, rectangle2: player }) &&
                enemy.isAttacking) {

                enemy.isAttacking = false;
                player.takeHit(enemy.damage);
                createParticles(player.position.x + player.width / 2, player.position.y + player.height / 2, '#2ed573');
                screenShake();
                document.getElementById('playerHealth').style.width = (player.health / player.maxHealth) * 100 + '%';
                if (player.health <= 0) determineWinner({ player, enemy, timerId });
            }

            // Particles
            particles.forEach((particle, index) => {
                if (particle.alpha <= 0) particles.splice(index, 1);
                else particle.update();
            });
        }

        let frameCount = 0;
        setInterval(() => frameCount++, 1000 / 60);

        // --- 6. Input ---
        window.addEventListener('keydown', (event) => {
            if (!gameRunning) return;
            switch (event.key.toLowerCase()) {
                case 'd':
                    keys.d.pressed = true;
                    player.lastKey = 'd';
                    break;
                case 'a':
                    keys.a.pressed = true;
                    player.lastKey = 'a';
                    break;
                case 'w':
                    if (player.position.y + player.height >= GROUND_Y) {
                        player.velocity.y = player.jumpPower;
                    }
                    break;
                case ' ':
                    player.attack();
                    break;
            }
        });

        window.addEventListener('keyup', (event) => {
            switch (event.key.toLowerCase()) {
                case 'd': keys.d.pressed = false; break;
                case 'a': keys.a.pressed = false; break;
            }
        });

    </script>
</body>

</html>