<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>カスタム棒人間バトル：Mobile Edition</title>
    <meta name="description" content="スマホ対応。ステータスを割り振って戦う棒人間格闘ゲーム。">
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto+Mono:wght@400;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212;
            --ui-bg: rgba(20, 20, 30, 0.95);
            --accent: #ff4757;
            --text: #ffffff;
            --neon-blue: #2ed573;
            --neon-yellow: #ffa502;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-color);
            font-family: 'Roboto Mono', monospace;
            color: var(--text);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
            /* スマホでのスクロール防止 */
            -webkit-user-select: none;
            /* テキスト選択防止 */
            user-select: none;
        }

        /* UI Container */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        /* Screens */
        .screen {
            pointer-events: auto;
            background: var(--ui-bg);
            padding: 30px;
            border-radius: 12px;
            border: 2px solid #333;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            max-width: 600px;
            width: 90%;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-family: 'Black Ops One', cursive;
            font-size: 2rem;
            margin: 0 0 10px 0;
            color: var(--accent);
            text-transform: uppercase;
            text-shadow: 2px 2px 0px #fff;
            line-height: 1.2;
        }

        .hidden {
            display: none !important;
        }

        /* Customization Controls */
        .stat-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-size: 1rem;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            font-size: 1rem;
        }

        .stat-value {
            color: var(--neon-blue);
            font-weight: bold;
            width: 30px;
            text-align: right;
        }

        input[type="range"] {
            width: 50%;
            cursor: pointer;
            accent-color: var(--accent);
        }

        .weapon-select {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        .weapon-btn {
            background: #333;
            border: 2px solid #555;
            color: #fff;
            padding: 8px 12px;
            cursor: pointer;
            font-family: inherit;
            transition: 0.2s;
            font-size: 0.8rem;
            border-radius: 4px;
        }

        .weapon-btn.selected {
            border-color: var(--neon-yellow);
            background: #444;
            box-shadow: 0 0 10px rgba(255, 165, 2, 0.4);
            transform: scale(1.05);
        }

        .action-btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.2rem;
            font-family: 'Black Ops One', cursive;
            cursor: pointer;
            margin-top: 15px;
            transform: skew(-10deg);
            transition: 0.2s;
            box-shadow: 0 4px 0 #b33939;
        }

        .action-btn:hover {
            transform: skew(-10deg) translateY(-2px);
        }

        .action-btn:active {
            transform: skew(-10deg) translateY(2px);
            box-shadow: 0 2px 0 #b33939;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 5;
        }

        .health-bar-container {
            width: 40%;
            height: 20px;
            background: #333;
            border: 2px solid #fff;
            position: relative;
            transform: skew(-20deg);
        }

        .health-bar {
            height: 100%;
            background: var(--neon-blue);
            width: 100%;
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .enemy-bar {
            background: var(--accent);
            float: right;
        }

        #timer {
            font-family: 'Black Ops One', cursive;
            font-size: 2rem;
            color: white;
            text-shadow: 0 0 10px black;
        }

        /* --- Mobile Controls (New!) --- */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            box-sizing: border-box;
            pointer-events: none;
            /* UIレイヤーの下だが、ボタン自体はpointer-events:autoにする */
            z-index: 20;
        }

        .control-group {
            display: flex;
            gap: 15px;
            align-items: flex-end;
            pointer-events: auto;
        }

        .touch-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(4px);
            border-radius: 50%;
            color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Black Ops One';
            font-size: 1.5rem;
            user-select: none;
            touch-action: manipulation;
            transition: background 0.1s, transform 0.1s;
        }

        .touch-btn:active,
        .touch-btn.active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
            border-color: rgba(255, 255, 255, 0.8);
        }

        /* Directional Pad */
        .btn-move {
            width: 60px;
            height: 60px;
        }

        /* Action Buttons */
        .btn-jump {
            width: 70px;
            height: 70px;
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            font-size: 1rem;
            margin-bottom: 20px;
            /* Offset for thumb arc */
        }

        .btn-atk {
            width: 90px;
            height: 90px;
            border-color: var(--accent);
            color: var(--accent);
            background: rgba(255, 71, 87, 0.15);
            font-size: 1.2rem;
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div id="mobile-controls" class="hidden">
        <div class="control-group">
            <div id="btnLeft" class="touch-btn btn-move">←</div>
            <div id="btnRight" class="touch-btn btn-move">→</div>
        </div>
        <div class="control-group">
            <div id="btnJump" class="touch-btn btn-jump">JUMP</div>
            <div id="btnAtk" class="touch-btn btn-atk">ATK</div>
        </div>
    </div>

    <div id="ui-layer">

        <div id="hud" class="hidden">
            <div class="health-bar-container">
                <div id="playerHealth" class="health-bar"></div>
            </div>
            <div id="timer">60</div>
            <div class="health-bar-container" style="border-color: #ff4757;">
                <div id="enemyHealth" class="health-bar enemy-bar"></div>
            </div>
        </div>

        <div id="startScreen" class="screen">
            <h1>Stick Forge</h1>
            <p style="letter-spacing: 2px; margin-bottom: 15px; font-size:0.9rem;">BUILD YOUR FIGHTER</p>

            <div class="stat-header">
                <span>TOTAL POINTS</span>
                <span id="pointsDisplay" style="color:var(--neon-yellow);">7 / 10</span>
            </div>

            <div class="stat-row">
                <label>STR (攻撃)</label>
                <input type="range" id="strRange" min="1" max="8" value="1" oninput="updatePoints('strRange')">
                <span id="strVal" class="stat-value">1</span>
            </div>
            <div class="stat-row">
                <label>AGI (速度)</label>
                <input type="range" id="agiRange" min="1" max="8" value="1" oninput="updatePoints('agiRange')">
                <span id="agiVal" class="stat-value">1</span>
            </div>
            <div class="stat-row">
                <label>VIT (体力)</label>
                <input type="range" id="vitRange" min="1" max="8" value="1" oninput="updatePoints('vitRange')">
                <span id="vitVal" class="stat-value">1</span>
            </div>

            <p style="margin-top: 20px; font-size: 0.8rem; color: #aaa;">SELECT WEAPON</p>
            <div class="weapon-select">
                <button class="weapon-btn selected" onclick="selectWeapon('sword', this)">SWORD</button>
                <button class="weapon-btn" onclick="selectWeapon('axe', this)">AXE</button>
                <button class="weapon-btn" onclick="selectWeapon('spear', this)">SPEAR</button>
            </div>

            <button class="action-btn" onclick="startGame()">BATTLE START</button>
            <p style="margin-top:10px; font-size:0.7rem; color:#aaa;">PC: W/A/D/Space | Mobile: Touch Controls</p>
        </div>

        <div id="gameOverScreen" class="screen hidden">
            <h1 id="winnerText">YOU WIN</h1>
            <button class="action-btn" onclick="location.reload()">RE-FORGE</button>
        </div>
    </div>

    <script>
        // --- 1. Game Constants & Setup ---
        const canvas = document.getElementById('gameCanvas');
        const c = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Recalculate Ground Y on resize
            if (window.gameRunning) GROUND_Y = canvas.height - 100;
        }
        window.addEventListener('resize', resize);
        resize();

        const GRAVITY = 0.7;
        let GROUND_Y = canvas.height - 100;
        const MAX_TOTAL_POINTS = 10;

        const keys = {
            a: { pressed: false },
            d: { pressed: false },
            w: { pressed: false },
            space: { pressed: false }
        };

        let animationId;
        let timer = 60;
        let timerId;
        let gameRunning = false;

        // --- 2. Logic Functions ---

        function updatePoints(changedId) {
            const strInput = document.getElementById('strRange');
            const agiInput = document.getElementById('agiRange');
            const vitInput = document.getElementById('vitRange');

            let str = parseInt(strInput.value);
            let agi = parseInt(agiInput.value);
            let vit = parseInt(vitInput.value);
            let currentTotal = str + agi + vit;

            if (currentTotal > MAX_TOTAL_POINTS) {
                const excess = currentTotal - MAX_TOTAL_POINTS;
                if (changedId === 'strRange') { str -= excess; strInput.value = str; }
                else if (changedId === 'agiRange') { agi -= excess; agiInput.value = agi; }
                else if (changedId === 'vitRange') { vit -= excess; vitInput.value = vit; }
                currentTotal = MAX_TOTAL_POINTS;
            }

            document.getElementById('strVal').innerText = str;
            document.getElementById('agiVal').innerText = agi;
            document.getElementById('vitVal').innerText = vit;
            const remaining = MAX_TOTAL_POINTS - currentTotal;
            document.getElementById('pointsDisplay').innerText = `${currentTotal} / ${MAX_TOTAL_POINTS}`;
            document.getElementById('pointsDisplay').style.color = remaining === 0 ? 'var(--neon-blue)' : 'var(--neon-yellow)';
        }
        updatePoints();

        let selectedWeapon = 'sword';
        function selectWeapon(type, btn) {
            selectedWeapon = type;
            document.querySelectorAll('.weapon-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
        }

        // --- 3. Classes ---

        class Sprite {
            constructor({ position, velocity, color = 'red', offset = { x: 0, y: 0 } }) {
                this.position = position;
                this.velocity = velocity;
                this.width = 50;
                this.height = 150;
                this.lastKey;
                this.attackBox = {
                    position: { x: this.position.x, y: this.position.y },
                    offset: offset,
                    width: 100,
                    height: 50
                };
                this.color = color;
                this.isAttacking;
                this.health = 100;
                this.maxHealth = 100;
                this.damage = 10;
                this.speed = 5;
                this.jumpPower = -15;
                this.weaponType = 'sword';
                this.dead = false;
            }

            draw() {
                c.strokeStyle = this.color;
                c.lineWidth = 4;
                c.fillStyle = this.color;

                const x = this.position.x;
                const y = this.position.y;
                const w = this.width;
                const h = this.height;

                // Body Drawing
                c.beginPath(); c.arc(x + w / 2, y, 20, 0, Math.PI * 2); c.stroke();
                c.beginPath(); c.moveTo(x + w / 2, y + 20); c.lineTo(x + w / 2, y + 80); c.stroke();
                c.beginPath(); c.moveTo(x + w / 2, y + 80); c.lineTo(x, y + h); c.moveTo(x + w / 2, y + 80); c.lineTo(x + w, y + h); c.stroke();

                const facingRight = this.attackBox.offset.x >= 0;
                const armOriginX = x + w / 2;
                const armOriginY = y + 40;
                c.beginPath(); c.moveTo(armOriginX, armOriginY);

                let handX, handY;
                if (this.isAttacking) {
                    handX = armOriginX + (facingRight ? 60 : -60);
                    handY = armOriginY + 10;
                } else {
                    handX = armOriginX + (facingRight ? 30 : -30);
                    handY = armOriginY + 40;
                }
                c.lineTo(handX, handY); c.stroke();
                this.drawWeapon(handX, handY, facingRight);
            }

            drawWeapon(handX, handY, facingRight) {
                c.fillStyle = '#cbd5e1';
                const dir = facingRight ? 1 : -1;

                if (this.weaponType === 'sword') {
                    c.fillRect(handX, handY - 30, 40 * dir, 6);
                    c.fillStyle = '#475569'; c.fillRect(handX, handY - 5, 10 * dir, 10);
                } else if (this.weaponType === 'axe') {
                    c.fillStyle = '#8B4513'; c.fillRect(handX, handY - 40, 6 * dir, 60);
                    c.fillStyle = '#94a3b8'; c.fillRect(handX + (5 * dir), handY - 40, 25 * dir, 20);
                } else if (this.weaponType === 'spear') {
                    c.fillStyle = '#8B4513'; c.fillRect(handX - (20 * dir), handY, 100 * dir, 4);
                    c.fillStyle = '#cbd5e1'; c.fillRect(handX + (80 * dir), handY - 1, 15 * dir, 6);
                }
            }

            update() {
                this.draw();
                if (!this.dead) {
                    this.position.x += this.velocity.x;
                    this.position.y += this.velocity.y;
                }
                if (this.position.y + this.height + this.velocity.y >= GROUND_Y) {
                    this.velocity.y = 0;
                    this.position.y = GROUND_Y - this.height;
                } else {
                    this.velocity.y += GRAVITY;
                }

                if (this.lastKey === 'a') this.attackBox.offset.x = -this.attackBox.width;
                else if (this.lastKey === 'd') this.attackBox.offset.x = 0;

                this.attackBox.position.x = this.position.x + this.attackBox.offset.x;
                if (this.attackBox.offset.x < 0) this.attackBox.position.x = this.position.x - (this.attackBox.width - this.width);
                else this.attackBox.position.x = this.position.x;
                this.attackBox.position.y = this.position.y;

                if (this.position.x < 0) this.position.x = 0;
                if (this.position.x + this.width > canvas.width) this.position.x = canvas.width - this.width;
            }

            attack() {
                if (this.isAttacking) return;
                this.isAttacking = true;
                setTimeout(() => { this.isAttacking = false; }, 100 * (6 / this.speed));
            }

            takeHit(amt) {
                this.health -= amt;
                if (this.health <= 0) { this.health = 0; this.dead = true; }
            }
        }

        class Particle {
            constructor({ position, velocity, color }) {
                this.position = position; this.velocity = velocity; this.radius = Math.random() * 5 + 3;
                this.color = color; this.alpha = 1;
            }
            draw() {
                c.save(); c.globalAlpha = this.alpha; c.fillStyle = this.color;
                c.fillRect(this.position.x, this.position.y, this.radius, this.radius); c.restore();
            }
            update() {
                this.draw(); this.velocity.x *= 0.95; this.velocity.y += 0.3;
                this.position.x += this.velocity.x; this.position.y += this.velocity.y; this.alpha -= 0.05;
            }
        }

        let player, enemy;
        let particles = [];

        function createParticles(x, y, color) {
            for (let i = 0; i < 10; i++) {
                particles.push(new Particle({
                    position: { x: x, y: y },
                    velocity: { x: (Math.random() - 0.5) * 15, y: (Math.random() - 0.5) * 15 },
                    color: color
                }));
            }
        }

        function screenShake() {
            const intensity = 8;
            canvas.style.transform = `translate(${Math.random() * intensity - intensity / 2}px, ${Math.random() * intensity - intensity / 2}px)`;
            setTimeout(() => { canvas.style.transform = 'translate(0,0)'; }, 50);
        }

        function rectangularCollision({ rectangle1, rectangle2 }) {
            return (
                rectangle1.attackBox.position.x + rectangle1.attackBox.width >= rectangle2.position.x &&
                rectangle1.attackBox.position.x <= rectangle2.position.x + rectangle2.width &&
                rectangle1.attackBox.position.y + rectangle1.attackBox.height >= rectangle2.position.y &&
                rectangle1.attackBox.position.y <= rectangle2.position.y + rectangle2.height
            )
        }

        function determineWinner({ player, enemy, timerId }) {
            clearTimeout(timerId);
            document.getElementById('winnerText').style.display = 'flex';
            document.getElementById('gameOverScreen').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('mobile-controls').classList.add('hidden'); // Hide controls

            if (player.health === enemy.health) {
                document.getElementById('winnerText').innerText = 'DRAW';
                document.getElementById('winnerText').style.color = 'white';
            } else if (player.health > enemy.health) {
                document.getElementById('winnerText').innerText = 'YOU WIN!';
                document.getElementById('winnerText').style.color = 'var(--neon-blue)';
            } else {
                document.getElementById('winnerText').innerText = 'YOU LOSE...';
                document.getElementById('winnerText').style.color = 'var(--accent)';
            }
            gameRunning = false;
        }

        function decreaseTimer() {
            if (timer > 0) {
                timerId = setTimeout(decreaseTimer, 1000);
                timer--;
                document.getElementById('timer').innerText = timer;
            } else {
                determineWinner({ player, enemy, timerId });
            }
        }

        function startGame() {
            GROUND_Y = canvas.height - 100;
            const pStr = parseInt(document.getElementById('strRange').value);
            const pAgi = parseInt(document.getElementById('agiRange').value);
            const pVit = parseInt(document.getElementById('vitRange').value);

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('mobile-controls').classList.remove('hidden'); // Show controls

            player = new Sprite({
                position: { x: 100, y: 0 }, velocity: { x: 0, y: 0 }, offset: { x: 0, y: 0 }, color: '#2ed573'
            });
            player.maxHealth = pVit * 25; player.health = player.maxHealth;
            player.speed = 2 + (pAgi * 1.5); player.damage = pStr * 5;
            player.weaponType = selectedWeapon;
            player.lastKey = 'd';

            if (selectedWeapon === 'axe') { player.damage *= 1.4; player.speed *= 0.85; player.attackBox.width = 80; }
            if (selectedWeapon === 'spear') { player.damage *= 0.8; player.speed *= 1.1; player.attackBox.width = 180; }

            enemy = new Sprite({
                position: { x: canvas.width - 200, y: 0 }, velocity: { x: 0, y: 0 }, offset: { x: -50, y: 0 }, color: '#ff4757'
            });
            enemy.weaponType = ['sword', 'axe', 'spear'][Math.floor(Math.random() * 3)];
            enemy.lastKey = 'a';

            const eStr = Math.floor(Math.random() * 5) + 2;
            const eVit = Math.floor(Math.random() * 5) + 2;
            const eAgi = 10 - eStr - eVit;

            enemy.maxHealth = Math.max(2, eVit) * 25; enemy.health = enemy.maxHealth;
            enemy.damage = Math.max(2, eStr) * 5; enemy.speed = 2 + (Math.max(1, eAgi) * 1.5);

            if (enemy.weaponType === 'axe') { enemy.damage *= 1.4; enemy.speed *= 0.85; enemy.attackBox.width = 80; }
            if (enemy.weaponType === 'spear') { enemy.damage *= 0.8; enemy.speed *= 1.1; enemy.attackBox.width = 180; }

            particles = [];
            gameRunning = true;
            timer = 60;
            decreaseTimer();
            animate();
        }

        function animate() {
            if (!gameRunning) return;
            animationId = window.requestAnimationFrame(animate);
            c.fillStyle = '#0f172a'; c.fillRect(0, 0, canvas.width, canvas.height);
            c.fillStyle = '#1e293b'; c.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);

            player.update(); enemy.update();

            player.velocity.x = 0;
            if (keys.a.pressed && player.lastKey === 'a') player.velocity.x = -player.speed;
            else if (keys.d.pressed && player.lastKey === 'd') player.velocity.x = player.speed;

            // AI
            const dist = player.position.x - enemy.position.x;
            enemy.velocity.x = 0;
            if (!enemy.dead && !player.dead) {
                const attackRange = enemy.attackBox.width - 20;
                if (Math.abs(dist) > attackRange) {
                    if (dist > 0) { enemy.velocity.x = enemy.speed * 0.6; enemy.lastKey = 'd'; }
                    else { enemy.velocity.x = -enemy.speed * 0.6; enemy.lastKey = 'a'; }
                } else {
                    if (dist > 0) enemy.lastKey = 'd'; else enemy.lastKey = 'a';
                    if (Math.random() < 0.03) enemy.attack();
                }
                if (Math.random() < 0.005 && enemy.position.y + enemy.height >= GROUND_Y) enemy.velocity.y = -12;
            }

            // Collisions
            if (rectangularCollision({ rectangle1: player, rectangle2: enemy }) && player.isAttacking && player.currentAttackFrame !== frameCount) {
                player.isAttacking = false; enemy.takeHit(player.damage);
                createParticles(enemy.position.x + enemy.width / 2, enemy.position.y + enemy.height / 2, '#ff4757');
                screenShake(); document.getElementById('enemyHealth').style.width = (enemy.health / enemy.maxHealth) * 100 + '%';
                if (enemy.health <= 0) determineWinner({ player, enemy, timerId });
            }
            if (rectangularCollision({ rectangle1: enemy, rectangle2: player }) && enemy.isAttacking) {
                enemy.isAttacking = false; player.takeHit(enemy.damage);
                createParticles(player.position.x + player.width / 2, player.position.y + player.height / 2, '#2ed573');
                screenShake(); document.getElementById('playerHealth').style.width = (player.health / player.maxHealth) * 100 + '%';
                if (player.health <= 0) determineWinner({ player, enemy, timerId });
            }

            particles.forEach((particle, index) => {
                if (particle.alpha <= 0) particles.splice(index, 1); else particle.update();
            });
        }

        let frameCount = 0;
        setInterval(() => frameCount++, 1000 / 60);

        // --- Input Listeners (Keyboard) ---
        window.addEventListener('keydown', (event) => {
            if (!gameRunning) return;
            switch (event.key.toLowerCase()) {
                case 'd': keys.d.pressed = true; player.lastKey = 'd'; break;
                case 'a': keys.a.pressed = true; player.lastKey = 'a'; break;
                case 'w': if (player.position.y + player.height >= GROUND_Y) player.velocity.y = player.jumpPower; break;
                case ' ': player.attack(); break;
            }
        });
        window.addEventListener('keyup', (event) => {
            switch (event.key.toLowerCase()) {
                case 'd': keys.d.pressed = false; break;
                case 'a': keys.a.pressed = false; break;
            }
        });

        // --- Input Listeners (Touch / Mobile) ---
        function setupTouch(btnId, actionDown, actionUp) {
            const btn = document.getElementById(btnId);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scroll/zoom
                btn.classList.add('active');
                if (actionDown) actionDown();
            }, { passive: false });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                btn.classList.remove('active');
                if (actionUp) actionUp();
            }, { passive: false });
        }

        setupTouch('btnLeft', () => { keys.a.pressed = true; player.lastKey = 'a'; }, () => { keys.a.pressed = false; });
        setupTouch('btnRight', () => { keys.d.pressed = true; player.lastKey = 'd'; }, () => { keys.d.pressed = false; });
        setupTouch('btnJump', () => { if (player.position.y + player.height >= GROUND_Y) player.velocity.y = player.jumpPower; }, null);
        setupTouch('btnAtk', () => { player.attack(); }, null);

    </script>
</body>

</html>
